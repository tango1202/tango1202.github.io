---
layout: single
title: "#2. [개체지향 원칙] 단일 책임 원칙(Single Responsibility Principle)(작성중)"
categories: "principle"
tag: ["개체지향 원칙"]
author_profile: false
sidebar: 
    nav: "docs"
---

단일 책임 원칙은 **개체는 단 하나의 책임만 가져야 한다** 는 원칙입니다.

조금 풀어 쓰면,

1. 하나의 기능만 담당하고, 
2. 개체간의 종속성/연관성은 최소화 하고,
3. 단위 기능의 응집력은 높이고,
4. 해당 기능에 대한 예외 상황에 책임을 지고 대처하라

라는 뜻입니다.

한 개체에 책임이 많아지면 많은 기능을 포함해야 하고, 자연스레 기능끼리의 결합도가 높아지며, 코드 수정시에 사이드 이펙트가 발생할 소지가 높습니다. 그리고 무엇보다 가독성이 떨어져 분석이 힘들어지죠.

그렇다고, 개체를 그냥 기능 단위로 볶음밥 야채처럼 잘게 쪼개면 안됩니다.

잘못 쪼개지면, 오히려 여러 개체에서 기능과 책임을 분산해서 처리하기 때문에, 코드 수정의 범위가 넓어지고, 디버깅과 문제 파악이 어려워져 수정시 사이드 이펙트가 발생할 확률이 높아집니다.

문장 자체는 참 이해하기 쉽고 공감가는 원칙이지만, 준수하기에는 참 어려운 원칙중 하나입니다.

**잘 만들어라...** 라는 느낌과 좀 비슷하다 랄까요?

**해결 방법 : 클래스 쪼개기**

1. 클래스 주제에 맞게 쪼개라
데이터를 저장하는 클래스인지, 데이터를 처리하는 클래스인지, 데이터를 표시하는 클래스 인지 주제를 나누고, 혹은 이들을 모두 처리하는 컴포넌트나 모듈로 주제를 나누고 쪼갤 수 있겠습니다. 데이터도 고객 데이터인지, 직원데이터인지 구분해서 쪼갤 수 있겠고요. 한 단위의 주제로 응집될 수 있다면 쪼갭니다.
3. 클래스 설명이 1개 문장으로 표현될 수 있도록 쪼개라
설명이 길여지면 기능 단위로 나눕니다.
5. View와 Model을 쪼개고, 그 둘을 이어주는 개체를 만들어라(MVC, MVP, MVVM)
데이터에 따라 다양한 View(화면, 프린터, 미이보기, 차트로 보기, 표로 보기, json 보기)가 있을 수 있고, 일부 view는 시스템 종속적입니다. view는 데이터와 꼭 쪼개져야 합니다.

5. 데이터를 이용하여 무언가를 처리하는 로직과 처리결과 리포팅/로깅/출력은 분리하라.
viewModel 사상을 적용하면 좋습니다. 실제 데이터와 출력을 위한 데이터를 구분하도록 말이죠.

zoom 대화상자 예시 : 숫자를 저장하고 있지만, view데이터는 라디오로 구성되었을때.


7. 파일 입출력을 합치지 말고, Load, Save로 쪼개라 
불러오기용 파일 필터와 저장하기용 파일 필터가 서로 다를 수 있기 때문에 쪼개는게 좋습니다.
7. 시스템 리소스에 접근하는 아답터는 분리하라.
시스템 리소스 접근 방식이나 연결 방식이 변경될수 있기 때문에 쪼개는게 좋습니다.
9. 출력 방법은 분리하라.
프레임워크나 장치별로 렌더링 엔진은 변경될 수 있습니다. 쪼개두는게 좋습니다.
11. 입력 방법은 분리하라.
프레임워크나 장치별로 입력 방법이 달라질 수 있습니다. 쪼개는게 좋습니다.

12. UI 프레임워크는 쪼개두는게 좋습니다.
UI 프레임워크는 종종 유행에 따라 변경됩니다.

**해결 방법 : 3분할 원칙으로 쪼개라**

**해결 방법 : 잘못 쪼갰다면 산탄총 수술로 합쳐라**

만약 코드를 수정할때 여러 개체들을 수정해야 하거나 코드 중복이 발견됐다면, 너무 세분화해서 쪼갰다는 뜻입니다. 응집력이 낮다는 신호 입니다. 리팩토링의 냄새가 나죠? 이럴때 산탄총 수술이 필요합니다.

하기는 개체의 로그를 저장하는 개체들입니다. 로그 저장 로직을 단일 책임 원칙에 따라 각자 구현했지만, 매번 세트로 함께 수정된다면, 이를 합치는게 유리합니다. 이제 단일 책임은 xxx로그 출력, xxx로그 출력으로 세분화 되는게 아니라, 로그 출력으로 퉁쳐진다고 보시면 되겠습니다.


이 원칙을 준수하면,

1. 코드 가독성이 높아집니다.
2. 예외에 안정적입니다.
3. 단위 기능에 집중하므로 유지보수시 복잡성이 낮아집니다.

