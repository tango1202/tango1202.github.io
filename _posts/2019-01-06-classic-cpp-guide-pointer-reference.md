---
layout: single
title: "#6. [고전 C++ 가이드] 포인터(Pointer)와 참조자(Reference)"
categories: "classic-cpp-guide"
tag: ["cpp"]
author_profile: false
sidebar: 
    nav: "docs"
---

> * 포인터 보다는 참조자를 사용하라.
> * 지역 변수의 참조자를 리턴하지 마라.

**개요**

|항목|포인터|참조자|
|--|--|--|
|정의|개체나 함수의 주소값 저장|개체의 별칭|
|nullable|가능|불가능|
|용량|32bit : 4byte, 64bit : 8byte|참조하는 개체의 별칭으로서 해당 용량은 스펙에 정의되지 않음. 다만, `sizeof()`시 참조하는 개체와 동일 크기를 리턴하도록 스펙에 정의됨.(`sizeof(T&) == sizeof(T)`)|
|초기화|생성하면서 초기화, 생성후 초기화 가능|생성하면서 초기화만 가능|
|값 변경|가능|불가능|

포인터와 참조자는 대상 개체를 가리키기 위한 자료형입니다. 주로 하기 경우에 사용됩니다.

1. 대상개체가 너무 커서 함수 인자나 리턴에서 사용시 복사 부하가 너무 큰 경우
2. 원본 데이터를 값을 확인하거나, 수정하고 싶은 경우
3. 함수를 전달하고 싶은 경우
4. 부모 개체를 통해 자식 개체를 사용하고 싶은 경우

포인터는 하기와 같이 사용합니다.

```cpp
int x = 20;
int* p = &x; // p는 x의 주소를 가집니다.
*p = 30; // p가 가리키는 곳이 30이 됩니다.
EXPECT_TRUE(*p == 30 && x == 30); 
```
참조자는 하기와 같이 사용합니다.

```cpp
int x = 20;
int& r = x; // r은 x의 별칭입니다.
r = 30; // x는 30이 됩니다.
EXPECT_TRUE(r == 30 && x == 30);
```

**안정적인 참조자**

포인터는 초기화를 하지 않아 쓰레기 값을 가지고 있거나, 널값을 가질 수 있는데 반해, 참조자는 생성시 항상 초기화 되어야 하고, 널이 될 수 없으며, 다른 참조로 변경도 안되기 때문에 안정적으로 사용할 수 있습니다.

```cpp
int& r; // (X) 컴파일 오류. 생성만 할 수 없습니다. 초기값을 넣어주어야 합니다. 쓰레기값을 가질 일이 없습니다.

int* p = nullptr;
int& r = *p; // (X) 오동작. *p로 nullptr 의 개체를 구하는 건 오동작 할 수 있습니다. 
r = 10; // (X) 오동작. 예외가 발생합니다. 이렇게 사용하시면 안됩니다.

int x = 10;
int y = 20;

int& r = x;
r = y; // (O) r 이 y를 참조하는 것이 아니라, y의 값을 대입 받습니다.
EXPECT_TRUE(x == 20 && r == 20 && y == 30); // r은 x를 참조하기 때문에 x와 같은 값입니다.

```
**널검사가 필요없는 참조자**

특히 참조자를 사용하면 널검사가 필요없어 코드가 좀더 간단해 집니다.

```cpp
// 포인터를 인자로 사용하면, 널검사가 필요합니다.
void f(int*p) {
    if (p == nullptr) {
        // p가 nullptr이면 뭘 해야 할까요?
    }
    *p = 20;
}

// 참조자를 인자로 사용하면, 널검사가 필요없습니다.
void f(int& r) {
    r = 20;
}
```

꼭 포인터를 써야만 하는 경우가 아니라면 참조자를 사용하시기 바랍니다.

**Dangling 참조자**

참조자 사용시 다음과 같이 지역 변수의 참조를 리턴할 경우에는 이미 소멸된 지역변수를 참조하여 비정상 동작합니다. 이러한 참조자를 Dangling 참조자 라고 합니다.(`const T&`와 같이 상수형 참조를 하면 지역 변수 참조를 리턴해도 괜찮다고 하는 분들이 있던데, 저는 안되더라구요. 혹시나 되시더라도, 멤버 변수 참조를 리턴하는 느낌을 주기 때문에, 안쓰시는게 좋습니다.) 

```cpp
int& GetX() { // 혹은 const int& GetX()도 마찬가지 입니다.
    int x = 10; // 고맙게도 컴파일 경고는 나와줍니다.
    return x; 
} 

int result = GetX(); // (X) 예외 발생. 이미 소멸된 지역변수를 참조함
```

**포인터 사용법**

포인터는 개체 포인터, 배열 포인터, 함수 포인터, 다형성 포인터, 멤버 변수 포인터, 멤버 함수 포인터의 형태로, 개체 정의, 함수 인자 정의, 함수 리턴 정의시 사용합니다. 

```cpp
// 개체 포인터
int obj = 10;
int* p1 = &obj; // *p1 수정 가능. p1 수정 가능
*p1 = 20;

const int* p2 = &obj; // *p2 수정 불가. p2 수정 가능
*p2 = 20; // (X) 컴파일 오류
p2 = p1;

int* const p3 = &obj; // *p3 수정 가능. p3 수정 불가
*p3 = 20;
p3 = p1; // (X) 컴파일 오류

const int* const p4 = &obj; // // *p4 수정 불가. p4 수정 불가
*p4 = 20; // (X) 컴파일 오류
p4 = p1; // (X) 컴파일 오류
```

```cpp
// 배열 포인터
int a[2] = {1, 2};

// 배열 자체를 가리키는 포인터
int(* p5)[2] = &a; // int[2]를 배열 가리키는 포인터 
EXPECT_TRUE((*p5)[0] == 1 && (*p5)[1] == 2); // (*p5) 로 배열 개체 접근

// 배열의 첫번째 요소를 가리키는 포인터
int* p6 = a; // 혹은 int* p6 = &a[0]; 
EXPECT_TRUE(*(p6 + 0) == 1 && *(p6 + 1) == 2);
EXPECT_TRUE(p6[0] == 1 && p6[1] == 2);    
```

```cpp
// 함수 포인터
void TestFunc(int) {}

void (*p6)(int) = &TestFunc;
void (*p7)(int) = &TestFunc;
void (*p8)(int) = TestFunc; // &TestFunc 랑 동일

p7(10); // (*p6)(10); 도 가능. TestFunc 함수 호출 
p8(10); // (*p7)(10); 도 가능. TestFunc 함수 호출        
```

```cpp
class Base {
public:
    int m_Value;
    virtual void f() { std::cout<<"Base"<<std::endl; }    
};
class Derived : public Base {
public:
    virtual void f() { std::cout<<"Derived"<<std::endl; }    
};
// 다형성 포인터
{
    Derived d;
    Base* p9 = &d; // 부모 클래스 포인터로 자식 클래스 제어
    p9->f(); // Derived 출력
}
// 멤버 변수 포인터 - 라이브러리 개발시 사용할 수도 있음
{
    int Base::* p10 = &Base::m_Value; // Base 클래스 멤버 변수 m을 가리킴
    Base b;
    b.*p10 = 10;
    EXPECT_TRUE(b.m_Value == 10);
}
// 멤버 함수 포인터 - 라이브러리 개발시 사용할 수도 있음
{
    void (Base::* p11)() = &Base::f; // Base 클래스 멤버 함수 f를 가리킴
    Base b;
    (b.*p11)(); // 멤버 함수 포인터는 괄호 필요. Base 출력
}  
```

**참조자 사용법**

참조자는 개체 참조자, 배열 참조자, 함수 참조자, 다형성 참조자의 형태로, 개체 정의, 함수 인자 정의, 함수 리턴 정의시 사용합니다. 

```cpp
// 개체 참조자
int obj = 10;
int& r1 = obj; // r1 수정 가능
r1 = 20; 

const int& r2 = obj; // const 형이어서 r2 수정 불가
// r2 = 20; // (X) 컴파일 오류

int& r3 = obj;
r3 = other; // (X) 컴파일 오류. 참조자는 값 변경 불가
int& r4 = 20; // (X) 컴파일 오류. T& 상수 참조 불가
const int& r5 = 20; // (O) const T&로 상수 참조 가능
```

```cpp
// 배열 참조자
int a[2];
int(& r6)[2] = a; // 괄호로 감쌈
r6[0] = 10;
EXPECT_TRUE(a[0] == 10);
```

```cpp
// 함수 참조자 
void (&r7)(int) = TestFunc;
r7(10); // TestFunc 함수 호출 
```

```cpp
// 다형성 참조자
Derived d;
Base& r8 = d; // 부모 클래스 참조자로 자식 클래스 제어
r8.f(); // Derived 출력
```