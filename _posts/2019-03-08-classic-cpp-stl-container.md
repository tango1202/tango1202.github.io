---
layout: single
title: "#8. [고전 C++ STL] 컨테이너"
categories: "classic-cpp-stl"
tag: ["cpp"]
author_profile: false
sidebar: 
    nav: "docs"
---

> * 삽입/삭제 성능, 검색 성능, 노드 구성 용량 부하를 검토하여 최적의 컨테이너를 선택하라.
> * 시퀀스 컨테이너인지 연관 컨테이너 인지에 따라 요소의 대입 연산자, 비교 연산자를 구현하라.

# 개요

타입이 같은 여러개의 요소롤 저장하고 관리하는 개체를 컨테이너라고 합니다.(Collection 이라고도 합니다.)

STL의 컨테이너는 다음 특징을 가지고 있습니다.

**동종 컨테이너**

같은 타입만 관리하며, 서로 다른 타입인 경우라도, 상속 관계를 가지고 있다면 부모 포인터로 관리할 수 있습니다. 

**비관입형**

관입형은 컨테이너 요소가 컨테이너 구성을 위한 노드 정보를 자체적으로 가지고 있는 것을 말하며,

```cpp
class MyClass {
    MyClass* m_Pre; // 이전
    MyClass* m_Next; // 다음
    int m_Value1; // 실제 값
    int m_Value2; // 실제 값
};
```

비 관입형은 노드 정보와 데이터 정보를 분리한 것을 말합니다.

```cpp
class MyClass {
    int m_Value1; // 실제 값
    int m_Value2; // 실제 값
};

class Node {
    Node* m_Pre; // 이전
    Node* m_Next; // 다음
    MyClass m_Value; // 실제 값
};
```

일반적으로 관입형이 실행 속도 성능은 좋으나 일반화의 어려움이 있어 STL은 비 관입형을 사용합니다.

**이터레이터**

이터레이터를 통해 요소 접근을 일반화 합니다.

# 시퀀스 컨테이너

요소들을 순차 저장합니다.

|항목|내용|
|--|--|
|`vector`|타입이 동일한 요소를 연속적인 메모리 공간에 관리<br/>배열과 유사<br/>요소 삽입/삭제에 비효율적임<br/>랜덤 접근 지원|
|`list`|타입이 동일한 요소를 연결된 리스트로 관리<br/>요소 삽입/삭제에 최적화<br/>양방향 순차 접근 지원, 랜덤 접근 불가|
|`queue`|타입이 동일한 요소를 선입선출 방식으로 관리<br/>`front()`시 선입된 요소 반환<br/>내부적으론 `deque`으로 구현됨|
|`stack`|타입이 동일한 요소를 후입선출 방식으로 관리|
|`deque`|양방향에서 입출력이 가능한 `queue`. 앞과 뒤에서 요소를 넣거나 뺄 수 있음<br/>양쪽 입력/삭제가 `list`와 같은 효율<br/>랜덤 접근은 `vector`와 같은 효율<br/>중간 입출력은 `vector`와 같이 비효율적임|
|`priority_queue`|우선 순위에 따라 정렬된 `queue`<br/>`top()`시 가장 큰 요소 반환<br/>내부적으론 `vector`로 구현됨|

# 연관 컨테이너

요소의 대소 비교가 필요하며, **Key**로 정렬하여 관리합니다.  

|항목|내용|
|--|--|
|`map`|**Key** - **Value** 쌍으로 관리함.<br/>**Key**에 기반한 **Value**의 빠른 접근 지원<br/>요소 삽입시 `<`에 의해 정렬됨.<br/>삽입되는 **Key**는 유일함<br/>첨자 연산 지원|
|`multimap`|`map`과 동일하며 중복 **Key**허용<br/>첨자 연산 지원 안함|
|`set`|**Key**만 요소로 삽입됨|
|`multiset`|`set`과 동일하며 중복 **Key**허용<br/>

# 컨테이너 선정

보통은 `map`과 `set`이 검색에 유리하지만, 연속 메모리를 가진 `vector`도 데이터 갯수가 적으면 속도가 빠르다. 따라서, 요소 갯수에 따라 가변적이므로 프로파일러로 속도 측정후 결정하는게 좋다.

|항목|`vector`|`list`|`map`, `set`|
|--|--|--|--|
|데이터 추가가 빈번한 경우|O|O|X|
|빈번한 삽입/삭제|X|O|X|
|랜덤 접근|O|X|O|
|비교적 컨테이너가 작은 경우 빈번한 검색|O|X|O|
|비교적 컨테이너가 큰 경우 빈번한 검색|X|X|O|


# 컨테이너 원소 규칙

컨테이너는 원소 삽입/삭제/검색/비교등을 위해 다음 연산자들을 지원해야 합니다.

**대입 연산자**

시퀀스 컨테이너, 연관 컨테이너에서는 대입 연산자를 지원해야 합니다.

```cpp
T& operator =(const T& other) {
    T temp(other);
    std::swap(*this, temp);
    return this;
}
```

**비교 연산자 `==`**

시퀀스 컨테이너는 `==`을 지원해야 합니다.

**비교 연산자 `<`**

연관 컨테이너는 `<`을 지원해야 합니다. 이때 [대소 비교의 논리 조건](https://tango1202.github.io/classic-cpp-guide/classic-cpp-guide-operators/#%EB%8C%80%EC%86%8C-%EB%B9%84%EA%B5%90%EC%9D%98-%EB%85%BC%EB%A6%AC-%EC%A1%B0%EA%B1%B4)을 충족해야 합니다.