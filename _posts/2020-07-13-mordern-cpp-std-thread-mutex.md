---
layout: single
title: "#13. [모던 C++ STL] (C++11~) thread, mutex"
categories: "mordern-cpp-stl"
tag: ["cpp"]
author_profile: false
sidebar: 
    nav: "docs"
---

# 쓰레드

프로세스(Process)는 프로그램이 컴퓨터 메몰리에 로딩되어 실행되고 있는 인스턴스 입니다.CPU에서 돌아가는 단위 입니다. 한마디로 실행중인 프로그램입니다.

쓰레드(Thread)는 프로세스 내에서 CPU의 실행 단위입니다. 멀티 쓰레드라고 하면, 여러개의 실행 단위가 있어 여러 작업을 동시에 할 수 있습니다.

싱글 쓰레드인 사람은 보고 난 후, 듣고 난후 말할 수 있지만, 멀티 쓰레드인 사람은 보면서 듣고 말할 수 있습니다.

아무래도 멀티 쓰레드가 동시에 작업하다 보니 작업시간은 단축될 수 있습니다. 

![image](https://github.com/tango1202/tango1202.github.io/assets/133472501/38aaa574-dcfc-427e-a084-a8480dbc2a63)

다만 헷갈려서 오동작 할 수 있죠. 본 것을 말해야 하는데, 정신 사나워서 들은걸 말할 수도 있습니다. 

컴퓨터도 마찬가지 입니다. 쓰레드를 이용한 병렬 프로그래밍 시에는 서로 다른 쓰레드가 동일한 자원을 사용할 때 **경쟁 상태(Race Condition)** 가 되어 잘못된 값을 사용하지 않도록 조정하고, 서로 자원 사용을 양보하다가 **데드락(Dead Lock)** 상태가 되지 않도록 신경 써야 합니다.  

# 경쟁 상태(Race Condition)

다음처럼 동일한 데이터를 서로 다른 쓰레드가 하나는 값을 저장하고, 하나를 값을 읽는다고 생각해 봅시다.

![image](https://github.com/tango1202/tango1202.github.io/assets/133472501/ce0506d4-9d71-4cf4-b416-d1803f518f13)

동시적으로 저장하고 읽다보니 쓰레드 B는 어느 값이 읽혀지는지 알 수 없습니다.(이런 상태를 경쟁상태(Race Condition)이라 합니다.) 따라서, 이렇게 공유되는 자원은 Lock을 걸어 다른 쓰레드가 잠시 대기하도록 해야 합니다.

![image](https://github.com/tango1202/tango1202.github.io/assets/133472501/7f4c7dd4-9b54-4e51-9fda-5a7b857f52a3)

만약 쓰레드 A가 데이터에 먼저 접근하여 Lock을 걸어두면, 쓰레드 A가 Lock을 풀어줄때까지 쓰레드 B는 대기합니다. 이후 쓰레드 A가 Lock을 풀어주면 그제서야 쓰레드 B가 데이터에 접근하여 값을 읽어줄 수 있습니다. 이때 쓰레드 B도 쓰레드 A가 대기할 수 있도록 Lock을 걸어줘야 합니다.

# 데드락(Dead Lock)

만약 쓰레드A 가 Lock을 걸기만 하고 풀지 않으면 어떻게 될까요? 쓰레드 B는 무한 대기하게 됩니다.(이런 상태를 데드락(Dead Lock)이라 합니다.) 이렇게 대기하면, 원하는 작업이 끝나지 않아 프로그램은 마치 멈춘것처럼 아무 동작도 안하고, 계속 대기하게 됩니다. 