---
layout: single
title: "#1. [고전 C++ 가이드] 예외 안전 코드"
categories: "classic-cpp-exception"
tag: ["cpp"]
author_profile: false
sidebar: 
    nav: "docs"
---

# 개요

예외 안전(safe) 코드는 예외가 발생하지 않는 코드가 아니라(이건 사실 불가능합니다. 메모리가 부족할 수도 있고, 갑자기 랜선이 차단될 수도 있고), 예외가 발생해도 안전하게 복원되고, 계속 동작할 수 있는 코드입니다.

예외에 안전하려면 다음을 준수하여야 합니다.

1. 예외 상황을 사전에 예측하고 프로그래밍 해야 합니다. 모든 함수는 실패할 수 있다고 가정하세요.
2. 예외가 발생했을때 메모리 릭이나 리소스 릭은 없어야 합니다.
3. 예외가 발생했을때 예외 발생 전의 상태로 복원해야 합니다.

# 일반적인 예외 상황에서 대처 방안

**메모리 할당 실패**

일반적으로는 특별히 할 수 있는게 없습니만, 안전하게 프로그랜을 종료 시킬 수 있도록 몇가지 추가 작업을 할 수 있습니다.

1. 메모리 핸들러를 이용하여 미리 할당한 예약 영역을 해제하고, 프로그램의 정상 종료를 위해 뭔가 시도해 볼 수 있습니다.
2. 100,000,000 G 와 같이 엄청난 크기를 할당 요청을 하는 바람에 실패했다면, 메시지로 메모리 부족을 알리고 요청전의 상태로 복원할 수 있습니다.
   
**컨테이너에서 잘못 참조된 인덱스**

1. 비교적 상위 모듈에서 사전에 잘못된 인덱스 인지 검사하고, 유효한 인덱스가 되도록 보정합니다.
2. 비교적 상위 모듈에서 에러 메시지를 표시하거나, 아무짓도 안하거나, 마지막 요소를 사용하거나, 정의된 기본 동작을 수행합니다.
   
**잘못 전달된 인수**

주로 프로그래머의 실수입니다.

1. 정상 동작할 수 있는 값인지 사전에 검사한뒤 함수를 호출합니다.
2. 비정상 값(경계값)인지 함수 내에서 진단하고, 널검사가 필요한 포인터보다는 널검사가 필없는 레퍼런스를 사용하여 진단 코드를 최소화 합니다.
3. 스스로 보정할 수 있는 값이면 수정해서 사용합니다.
4. 잘못 사용하기 어렵도록 코딩 계약을 단단하게 맺습니다.
5. 비교적 상위 모듈에서 에러 메시지를 표시하거나, 아무짓도 안하거나, 다른 인수값으로 재시도 합니다.

오버 플로우/연산오류

안전한 연산인지 검사
재귀 호출 안정성 검사
0으로 나누기. 0으로 나누게 될때의 동작을 예측할 것

인프라 오류

파일, 네트웍 등

# 예외 상황의 잘못된 대처

프로그램을 종료한다.
좀 무책임하지 않은가?

별 신경 쓰지 않는다.
프로그램이 죽든, 개발자가 죽든...

에러를 나타내는 값을 리턴한다, 혹은 전역 에러 코드를 세팅한다.
리턴된 에러는 대부분 무시될 확률이 높다. 
특히 전역 에러코드 세팅은 최악이다.(호출한 곳에서 에러 확인할 확률 1%. GetLastError())

현 함수를 정상적으로 종료시킨다. if (condition) return;
현 함수 종료후에 시스템이 정말 계속 안정적으로 돌아갈까?
이상한 방향으로 폭주하지는 않을까?

에러가 발생한 경우 호출할 함수를 호출한다.
고맙다. 신경 써 줘서... 하지만 어떻게 호출하지? 도대체 에러 보고는 어떻게 해야 하는거야?

# 예외 상황의 올바른 대처

현 함수에서 예측할 수 있는 모든 상황을 고려하라. 
기본 보증과 강한 보증을 수행하라.

예외대처 순서도.

기본 생성자는 피하라.
복사 생성자/대입 연산자의 컴파일 버전
소멸자에서 예외 발생 금지
Swap에서 예외 발생 금지
[완전한 생성자](https://tango1202.github.io/classic-cpp-oop/classic-cpp-oop-complete-class/#%EC%99%84%EC%A0%84%ED%95%9C-%EC%83%9D%EC%84%B1%EC%9E%90) 자원 획득과 초기화를 한번에



예외 안정 함수의 제어구조
사전에 정상적인 조건인지 확인후 실행할것
---





---


---


